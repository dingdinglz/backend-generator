package main

import (
	"backend-generator/global"
	"encoding/json"
	"os"
	"path/filepath"

	"github.com/dingdinglz/openai"
)

var docGeneratePrompt string = `下面我会给你一个json数组，这个json数组用来描述一组web服务器的路由，每个元素都是一个object，有两种情况，第一，这个元素的type为method，说明它是一个路由，method描述了它的请求方法，例如post，get，path描述了它的路径，例如/test，但是注意，一个路由会继承它父路由组的属性，例如，如果父路由组的path是/test，下面的一个路由的path为/test，这个路由的真正path是/test/test。req和resp分别描述了一个路由的请求参数和响应参数，它们也是一个对象数组，其中，name是字段名，type是字段的类型，optional描述该字段是否可以被忽略，也就是不被传入，omitempty描述当该字段为空的时候，是否返回。第二，这个元素的type为group，说明它是一个路由组，children描述了它的子路由，注意，children中可能嵌套group，path描述了该路由组的路径，middlewares描述了该路由组用到了哪些中间件，name描述了该路由组的名字。
然后，你需要根据我传入的信息生成一个api文档（markdown格式），内容覆盖所有接口，利用多级标题对api文档进行层级的划分，例如最顶层的路由组用二级标题，它的一个子路由组就用三级标题，按此类推。每个接口的内容都要包括接口功能描述，调用路径，传入参数，返回参数解释以及错误码解释（生成一个表格，两列分别是错误码，和错误信息即可，不需要填入内容，每个接口都需要一个），传入参数和返回参数以表格的形式呈现，表格中应当有一列是对传入/返回参数的解释，功能描述你可以根据路径名进行猜测，也可以留空，其他内容要严格符合传入的信息。
你仅需要返回生成的api文档的内容即可，不需要对生成做任何解释，返回的内容不需要用代码块包裹，标题中不允许存在一级标题，最大的标题应该是二级标题，生成完成后，在文档的末尾处加上generated by [backend-generator](https://github.com/dingdinglz/backend-generator)。`

func (app *App) GenerateDoc() string {
	settingBytes, e := os.ReadFile("setting.json")
	if e != nil {
		return "set"
	}
	setting := Setting{}
	e = json.Unmarshal(settingBytes, &setting)
	if e != nil {
		return "json"
	}
	routes, _ := json.Marshal(global.WorkSpaceConfig.Methods)
	client := openai.NewClient(&openai.ClientConfig{
		BaseUrl: setting.Ai.Base,
		ApiKey:  setting.Ai.Key,
	})
	res, e := client.EasyChat(setting.Ai.Model, docGeneratePrompt, string(routes))
	if e != nil {
		return e.Error()
	}
	os.WriteFile(filepath.Join(global.WorkSpace, "api-doc.md"), []byte(res), os.ModePerm)
	return ""
}
